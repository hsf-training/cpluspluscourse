\subsection[Refs]{References}

\begin{frame}[fragile]
  \frametitlecpp[98]{References}
  \begin{block}{References}
    \begin{itemize}
      \item References allow for direct access to another object
      \item They can be used as shortcuts / better readability
      \item They can be declared \mintinline{cpp}{const} to allow only read access
      \item They can be used as function arguments
    \end{itemize}
  \end{block}

  \begin{exampleblock}{Example:}
    \begin{cppcode*}{gobble=2}
      int i = 2;
      int &iref = i; // access to i
      iref = 3;      // i is now 3

      // const reference to a member:
      struct A { int x; int y; } a;
      const int &x = a.x; // direct read access to A's x
      x = 4;              // doesn't compile
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Pointers vs References}
  \begin{block}{Specificities of reference}
    \begin{itemize}
    \item Natural syntax
    \item Must be assigned when defined, cannot be \mintinline{cpp}{nullptr}
    \item Cannot be reassigned
    \item Non-const references to temporary objects are not allowed
    \end{itemize}
  \end{block}
  \begin{block}{Advantages of pointers}
    \begin{itemize}
    \item Can be reassigned to point elsewhere or to \mintinline{cpp}{nullptr}
    \item Clearly indicates that argument may be modified
    \end{itemize}
  \end{block}
  \pause
  \begin{goodpractice}{References}
    \begin{itemize}
      \item Always use references when you can
      \item Consider that a referenced object can be modified
      \item Use \mintinline{cpp}{const} when it's not the case
    \end{itemize}
  \end{goodpractice}
\end{frame}
