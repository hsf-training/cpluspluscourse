\subsection[Refs]{References}

\begin{frame}[fragile]
  \frametitlecpp[98]{References}
  \begin{block}{References}
    \begin{itemize}
      \item References allow for direct access to another object
      \item They can be used as shortcuts / better readability
      \item They can be declared \cppinline{const} to allow only read access
    \end{itemize}
  \end{block}

  \begin{exampleblock}{Example:}
    \begin{cppcode*}{}
      int i = 2;
      int &iref = i; // access to i
      iref = 3;      // i is now 3

      // const reference to a member:
      struct A { int x; int y; } a;
      const int &x = a.x; // direct read access to A's x
      x = 4;              // doesn't compile
      a.x = 4;            // fine
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Pointers vs References}
  \begin{block}{Specificities of reference}
    \begin{itemize}
    \item Natural syntax
    \item Cannot be \cppinline{nullptr}
    \item Must be assigned when defined, cannot be reassigned
    \item References to temporary objects must be \cppinline{const}
    \end{itemize}
  \end{block}
  \begin{block}{Advantages of pointers}
    \begin{itemize}
    \item Can be \cppinline{nullptr}
    \item Can be initialized after declaration, can be reassigned
    \end{itemize}
  \end{block}
  \pause
  \begin{goodpractice}{References}
    \begin{itemize}
      \item Prefer using references instead of pointers
      \item Mark references \cppinline{const} to prevent modification
    \end{itemize}
  \end{goodpractice}
\end{frame}
