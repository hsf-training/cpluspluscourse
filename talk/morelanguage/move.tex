\subsection[mv]{Move semantics}

\begin{frame}[fragile]
  \frametitlecpp[11]{Move semantics: the problem}
  \begin{exampleblock}{Inefficient code}
    \begin{cppcode*}{}
      void swap(std::vector<int> &a,
                std::vector<int> &b) {
        std::vector<int> c = a;
        a = b;
        b = c;
      }
      std::vector<int> v(10000), w(10000);
      ...
      swap(v, w);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{alertblock}{What happens during swap}
    \begin{itemize}
    \item one allocation and one release for 10k \cppinline{int}s
    \item a copy of 30k \cppinline{int}s
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Move semantics: the problem}
  \begin{exampleblock}{Vector's built-in efficient swap}
    \begin{cppcode*}{}
      std::vector<int> v(10'000), w(10'000);
      ...
      v.swap(w);
      \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{What happens during swap}
    \begin{itemize}
    \item 3 swaps of \cppinline{int*} (9 copies)
    \item only some pointers to the underlying storage are swapped
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Move semantics: the problem}
  \begin{exampleblock}{Another potentially inefficient code}
    \begin{overprint}
      \onslide<1-2>
      \begin{cppcode*}{}
        T consumeVector(std::vector<int> input) {
          // ... change elements, compute result
          return result;
        }

        std::vector<int> values{...};
        consumeVector(values); // being copied now
      \end{cppcode*}
      \onslide<3-4>
      \begin{cppcode*}{}
        T consumeVector(std::vector<int> const & input) {
          std::vector tmp{input};
          // ... change elements, compute result
          return result;
        }
        std::vector<int> values{...};
        consumeVector(values); // maybe copied internally?
      \end{cppcode*}
      \onslide<5->
      \begin{cppcode*}{}
        T consumeVector(std::vector<int> & input) {
          // ... change elements, compute result
          return result;
        }

        std::vector<int> values{...};
        consumeVector(values); // maybe modified?
        somethingElse(values); // safe to use values now???
      \end{cppcode*}
    \end{overprint}
  \end{exampleblock}
  \begin{overprint}
    \onslide<2>
    \begin{alertblock}{Pass by copy}
      \begin{itemize}
      \item One unnecessary (large?) allocation and release
      \item Unnecessary copy of the \cppinline{int}s
      \end{itemize}
    \end{alertblock}
    \onslide<4>
    \begin{alertblock}{Use references to avoid copies?}
      \begin{itemize}
      \item Working with pass by reference only moves allocation and copy to a different place
      \end{itemize}
    \end{alertblock}
    \onslide<5>
    \begin{alertblock}{So non-const references?}
      \begin{itemize}
      \item Non-\cppinline{const} references could work, but does the outside know that we're changing the vector?
      \item Could lead to bugs
      \end{itemize}
    \end{alertblock}
    \onslide<6>
    \begin{block}{The ideal situation}
      Have a way to express that we move the vector's content
    \end{block}
  \end{overprint}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Move semantics: value categories}
  \begin{block}{Lvalue (left value / locator value)}
    \begin{itemize}
      \item An expression is an lvalue
      \begin{itemize}
        \item If its evaluation determines identity of object/function
        \item If the object is not expiring (``xvalue'')
      \end{itemize}
      \item Lvalues have a persistent address in memory
      \item Lvalues can be assigned to unless \cppinline{const}
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Lvalue examples}
    \begin{cppcode*}{}
      int i;
      int & j = i;
      T t;
      t.m = 5; // lvalue, because t is lvalue
      ++i;     // returns underlying object
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Move semantics: value categories}
  \begin{block}{Rvalue}
    \begin{itemize}
      \item An expression is an rvalue when from these primary categories
      \begin{itemize}
        \item ``pure rvalue'': Result of built-in operator; initialiser of object
        \item ``xvalue'': Expiring value, resources can ``moved''
      \end{itemize}
      \item Has no persistent address in memory
      \begin{itemize}
        \item Cannot use the addressof operator
      \end{itemize}
      \item Cannot be used as left-hand operand of built-in assignments

    \end{itemize}
  \end{block}
  \vspace{-6mm}
  \begin{overprint}
    \onslide<1>
    \begin{exampleblock}{Examples for rvalues}
      \begin{cppcode*}{}
        i = 42;    // 42 is pure rv
        i = a + b; // a+b is pure rv
        T t = T{}; // T{} is pure rv
        i++;       // Pure rv (post-increment returns temp.)
        T{}.m;     // m is expiring because T{} is pure rv
        std::move(x); // Converts lvalue into xvalue
      \end{cppcode*}
    \end{exampleblock}
    \onslide<2>
    \begin{alertblock}{Things that don't compile with rvalues}
      \begin{cppcode*}{}
        a + b = 2; // Cannot assign to pure rv
        &(a+b);    // Cannot take address of pure rv
        &i++;      // Same, post-increment returns pure rv
        T{}.m = 2; // cannot assign if m is built-in type
      \end{cppcode*}
    \end{alertblock}
  \end{overprint}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Move semantics: Terminology}
  \begin{block}{Source of confusion}
    \begin{itemize}
      \item The name ``rvalue'' originates from them \textit{mostly} being on right-hand side
      \item But it denotes value categories of \emph{expressions}
      \item Rvalues can be assigned to for non-builtin types
    \end{itemize}
  \end{block}

  \begin{exampleblock}{Example: rvalue on left-hand side}
    \begin{cppcode*}{}
      struct T{
        int m;
        T& operator=(int i);
      };
      std::cout << (T{} = 5).m << "\n";
    \end{cppcode*}
  \end{exampleblock}

  \begin{alertblock}{Not possible with built-in types}
    \begin{cppcode*}{}
      std::cout << (int{} = 5) << "\n"; // Error
    \end{cppcode*}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Move semantics: rvalue references}
  \begin{block}{New reference type: rvalue reference}
    \begin{itemize}
      \item Declared with \cppinline{T&&}
      \item Does not bind to lvalues
    \end{itemize}
  \end{block}

  \begin{exampleblock}{Binding rules}
    \begin{columns}[onlytextwidth]
      \begin{column}{0.45\textwidth}
        Lvalues
        \begin{cppcode*}{linenos=false}
          T lv;
          T &     ref = lv;//OK
          T &&  rvref = lv;//Error
          T const& cr = lv;//OK
        \end{cppcode*}
      \end{column}
      \hfil
      \begin{column}{0.5\textwidth}
        Rvalues
        \begin{cppcode*}{linenos=false}

          T &     ref = T{};//Error
          T &&  rvref = T{};//OK
          T const& cr = T{};//OK
        \end{cppcode*}
      \end{column}
    \end{columns}
  \end{exampleblock}

  \begin{exampleblock}{Overload resolution prefers rvalue reference}
    \begin{cppcode*}{}
      void f(T const &);
      void f(T &&);      // Selected. Enables move
      f(T{});
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Move semantics}
  \begin{block}{The idea}
    \begin{itemize}
      \item use rvalue references to reuse resources
      \item 2 new special member functions in every class:
      \begin{description}
      \item[a move constructor] similar to copy constructor
      \item[a move assignment operator] similar to assignment operator (now called copy assignment operator)
      \end{description}
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Practically}
    \begin{cppcode*}{}
      T(T const & other); // copy construction
      T(      T&& other); // move construction
      T& operator=(T const & other); // copy assignment
      T& operator=(      T&& other); // move assignment
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Remember our bad vector implementation?}
  \begin{cppcode}
    class Vector {
    public:
      Vector(int n);
      Vector(Vector && other)
      : len(other.len), data(other.data)
      {
        other.len = 0;
        other.data = nulltpr; // Important! Double delete!
      }
      ~Vector();
    private:
      int len;
      int* data;
    };
    Vector::~Vector() { delete[] data; }
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Move semantics}
  \begin{block}{A few points}
    \begin{itemize}
    \item move constructor and assignment operator are allowed to leave the source object "empty"
      \begin{itemize}
      \item so do not use the source object afterward
      \item leave the source in a valid state (for its destructor)
      \end{itemize}
    \item if no move semantic is implemented, copies will be performed
    \item the language and STL understand move semantic
    \item the compiler uses copy elision or moves whenever possible
      \begin{itemize}
      \item e.g.\ when passing temporaries or returning from a function
      \end{itemize}
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Practically (in \cpp11)}
    \begin{cppcode*}{}
      T f() { T r; return r; } // move r out of f
      T v = f(); // move returned (temporary) T into v
      void g(T a, T b, T c);
      g(f(), T{}, v); // move, move, copy
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Move semantics}
  \begin{block}{In some cases, you want to force a move}
    \begin{cppcode*}{}
      void swap(T &a, T &b) {
        T c = a;  // copy construct
        a = b;    // copy assign
        b = c;    // copy assign
      }
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{Explicitly request moving}
    \begin{itemize}
    \item using the \cppinline{std::move} function
    \item which is basically a cast to an rvalue reference
    \end{itemize}
    \begin{cppcode*}{firstnumber=6}
      void swap(T &a, T &b) {
        T c = std::move(a);      // move construct
        a = std::move(b);        // move assign
        b = static_cast<T&&>(c); // move assign (don't)
      }
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Move semantics: recommended implementation}
  \begin{block}{Use copy and swap idiom}
    \begin{itemize}
    \item implement an efficient swap function for your class
      \begin{itemize}
      \item preferably hidden friend and symmetric
      \end{itemize}
    \item move constructor
      \begin{itemize}
      \item consider delegating to default constructor
      \item swap \cppinline{*this} with argument (source)
      \end{itemize}
    \item move assignment as \cppinline{operator=(T source)}
      \begin{itemize}
      \item argument passed by value; caller can move or copy into it
      \item swap argument with \cppinline{*this}
      \item end of scope: argument destroys former content of \cppinline{*this}
      \end{itemize}
    \item alternative: move assignment as \cppinline{operator=(T&& source)}
      \begin{itemize}
      \item swap argument with \cppinline{*this}
      \item 1 swap less, separate copy assignment operator needed
      \item former content of \cppinline{*this} destroyed with caller argument
      \end{itemize}
    \item swap, move constructor/assignment must be \cppinline{noexcept}!
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile,t]
  \frametitlecpp[11]{Move semantics: recommended implementation}
  \begin{exampleblock}{Practically}
    \small
    \begin{cppcode*}{}
      class Movable {
        Movable();
        Movable(const Movable &other);
        Movable(Movable &&other) noexcept :
          Movable() {         // constructor delegation
          swap(*this, other);
        }
        Movable& operator=(Movable other) noexcept { // by value
          swap(*this, other);
          return *this;
        }
        friend void swap(Movable &a, Movable &b) noexcept {...}
      };
      Movable a, b;
      a = b;            // operator= copies b into "other"
      a = std::move(b); // operator= moves b into "other"
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile,t]
  \frametitlecpp[11]{Move semantics: alternative implementation}
  \begin{exampleblock}{Practically}
    \small
    \begin{cppcode*}{}
      class Movable {
        Movable();
        Movable(const Movable &other);
        Movable(Movable &&other) noexcept :
          Movable() {         // constructor delegation
          swap(*this, other);
        }
        Movable& operator=(const Movable& other);
        Movable& operator=(Movable&& other) noexcept {
          swap(*this, other);
          return *this;
        }
        friend void swap(Movable &a, Movable &b) noexcept { ... }
      };
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile,t]
  \frametitlecpp[11]{Move semantics: Don't forget noexcept!}
  \begin{alertblock}{Vector pessimisation when move constructor can throw}
    \begin{itemize}
      \item When a vector reallocates, it must copy/move all elements
        \begin{itemize}
          \item An exception during move aborts the relocation of elements
          \item Move might not be revertible, so vector falls back to copy
          \item This can significantly slow down the resize operation
        \end{itemize}
      \item With \cppinline{noexcept}, the much faster move is used
    \end{itemize}
  \end{alertblock}
  \begin{exampleblock}{Vector resize with copy/move}
    \small
    \begin{cppcode*}{}
      struct Movable1 { Movable1(Movable1 &&other); };
      struct Movable2 { Movable2(Movable2 &&other) noexcept; };
      while (vector1.size() < 10000) {
        vector1.push_back(Movable1{}); // Copies
        vector2.push_back(Movable2{}); // Moves
      }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Move Semantic}
  \begin{exercise}{Move semantics}
    \begin{itemize}
    \item go to \texttt{exercises/move}
    \item look at the code and run it with callgrind
    \item understand how inefficient it is
    \item implement move semantic the easy way in NVector
    \item run with callgrind and see no improvement
    \item understand why and fix test.cpp
    \item see efficiency improvements
    \end{itemize}
  \end{exercise}
  prerequisite: be able to use simple templated code
\end{frame}
