\subsection[$\lambda$]{Lambdas}

\begin{frame}[fragile]
  \frametitlecpp[11]{Trailing function return type}
  \begin{block}{An alternate way to specify a function's return type}
    \begin{cppcode*}{linenos=false}
      ReturnType func(Arg1 a, Arg2 b);  // classic
      auto func(Arg1 a, Arg2 b) -> ReturnType;
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{Advantages}
    \begin{itemize}
    \item Allows to simplify inner type definition
      \begin{cppcode*}{gobble=4}
        class Class {
          using ReturnType = int;
          ReturnType func();
        }
        Class::ReturnType Class::func() {...}
        auto Class::func() -> ReturnType {...}
      \end{cppcode*}
    \item \cpp14: \cppinline{ReturnType} not required, compiler can deduce it
    \item used by lambda expressions
    \end{itemize}
  \end{block}
\end{frame}


\begin{frame}[fragile]
  \frametitlecpp[11]{Lambda expressions}
  \begin{block}{Definition}
    a lambda expression is a function with no name
  \end{block}
  \pause
  \begin{exampleblock}{Python example}
    \begin{pythoncode*}{}
      data = [1,9,3,8,3,7,4,6,5]

      # without lambdas
      def isOdd(n):
        return n%2 == 1
      print(filter(isOdd, data))

      # with lambdas
      print(filter(lambda n:n%2==1, data))
    \end{pythoncode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{\cpp Lambdas}
  \begin{block}{Simplified syntax}
    \begin{cppcode*}{}
      auto f = [] (arguments) -> return_type {
        statements;
      };
    \end{cppcode*}
    \begin{itemize}
    \item The return type specification is optional
    \item \cppinline{f} is an instance of a functor type, generated by the compiler
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Usage example}
    \begin{cppcode*}{firstnumber=4,gobble=2}
      int data[]{1,2,3,4,5};
      auto f = [](int i) {
        std::cout << i << " squared is " << i*i << '\n';
      };
      for (int i : data) f(i);
    \end{cppcode*}
  \end{exampleblock}
\end{frame}


\begin{frame}[fragile]
  \frametitlecpp[11]{Capturing variables}
  \begin{block}{Adaptable lambdas}
    \begin{itemize}
      \item Adapt lambda's behaviour by accessing variables outside of it
      \item This is called ``capture''
    \end{itemize}
  \end{block}
  \pause
  \begin{block}{First attempt in \cpp}
    \begin{cppcode}
      int increment = 3;
      int data[]{1,9,3,8,3,7,4,6,5};
      auto f = [](int x) { return x+increment; };
      for(int& i : data) i = f(i);
    \end{cppcode}
  \end{block}
  \pause
  \begin{alertblock}{Error}
    \begin{minted}[gobble=6]{text}
        error: 'increment' is not captured
          [](int x) { return x+increment; });
                                     ^
    \end{minted}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Capturing variables}
  \begin{block}{The capture list}
    \begin{itemize}
    \item local variables outside the lambda must be explicitly captured
    \begin{itemize}
      \item unlike in Python, Java, C\#, Rust, ...
    \end{itemize}
    \item captured variables are listed within initial \cppinline{[]}
    \end{itemize}
  \end{block}
  \pause
  \begin{exampleblock}{Example}
    \begin{cppcode*}{}
      int increment = 3;
      int data[]{1,9,3,8,3,7,4,6,5};
      auto f = [increment](int x) { return x+increment; };
      for(int& i : data) i = f(i);
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Default capture is by value}
  \begin{exampleblock}{Code example}
    \begin{cppcode}
      int sum = 0;
      int data[]{1,9,3,8,3,7,4,6,5};
      auto f = [sum](int x) { sum += x; };
      for (int i : data) f(i);
    \end{cppcode}
  \end{exampleblock}
  \pause
  \begin{alertblock}{Error}
    \begin{minted}[gobble=4]{text}
      error: assignment of read-only variable 'sum'
               [sum](int x) { sum += x; });
    \end{minted}
  \end{alertblock}
  \pause
  \begin{block}{Explanation}
    By default, variables are captured by value, and the lambda's \cppinline{operator()} is \cppinline{const}.
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Capture by reference}
  \begin{exampleblock}{Simple example}
    In order to capture by reference, add '\&' before the variable
    \begin{cppcode*}{}
      int sum = 0;
      int data[]{1,9,3,8,3,7,4,6,5};
      auto f = [&sum](int x) { sum += x; };
      for (int i : data) f(i);
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{exampleblock}{Mixed case}
    One can of course mix values and references
    \begin{cppcode*}{firstnumber=5}
      int sum = 0, offset = 1;
      int data[]{1,9,3,8,3,7,4,6,5};
      auto f = [&sum, offset](int x) { sum += x+offset; };
      for (int i : data) f(i);
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Capture list}
  \begin{block}{all by value}
    \begin{cppcode*}{linenos=false}
      [=](...) { ... };
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{all by reference}
    \begin{cppcode*}{linenos=false}
      [&](...) { ... };
    \end{cppcode*}
  \end{block}
  \pause
  \begin{block}{mix}
    \begin{cppcode*}{linenos=false}
      [&,  b](...) { ... };
      [=, &b](...) { ... };
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Capture list - this}
  \begin{block}{}
    Inside a (non-static) member function, we can capture \cppinline{this}.
  \end{block}
  \begin{block}{}
    \begin{cppcode*}{gobble=2}
      [   this](...) { use(*this); };
      [      &](...) { use(*this); };
      [&, this](...) { use(*this); };
      [      =](...) { use(*this); }; // deprecated in C++20
      [=, this](...) { use(*this); }; // allowed in C++20
    \end{cppcode*}
    Since the captured \cppinline{this} is a pointer, \cppinline{*this} refers to the object by reference.
  \end{block}
  \pause
  \begin{block}{}
    \begin{cppcode*}{gobble=2}
      [   *this](...) { use(*this); }; // C++17
      [&, *this](...) { use(*this); }; // C++17
      [=, *this](...) { use(*this); }; // C++17
    \end{cppcode*}
    The object at \cppinline{*this} is captured by value (the lambda gets a copy).
  \end{block}
  Details in  \href{https://www.nextptr.com/tutorial/ta1430524603/capture-this-in-lambda-expression-timeline-of-change}{this blog post}.
\end{frame}

\begin{advanced}

\begin{frame}[fragile]
  \frametitlecpp[11]{Anatomy of a lambda}
  \begin{block}{Lambdas are pure syntactic sugar - \cppinsightLink{https://cppinsights.io/s/67800da8}}
    \begin{itemize}
    \item they are replaced by a functor during compilation
    \end{itemize}
    \begin{columns}
      \scriptsize
      \begin{column}{.25\textwidth}
        \begin{cppcode*}{gobble=6}
          int sum = 0, off = 1;
          auto l =
          [&sum, off]



          (int x) {
            sum += x + off;
          };


          l(42);
        \end{cppcode*}
      \end{column}
      \begin{column}{.45\textwidth}
        \begin{cppcode*}{gobble=6, firstnumber=13}
          int sum = 0, off = 1;
          struct __lambda4 {
            int& sum;
            int off;
            __lambda4(int& s, int o)
            : sum(s), off(o) {}
            auto operator()(int x)const{
              sum += x + off;
            }
          };
          auto l = __lambda4{sum, off};
          l(42);
        \end{cppcode*}
      \end{column}
    \end{columns}
  \end{block}
  \begin{exampleblock}{Some nice consequence}
    \begin{itemize}
    \item lambda expressions create ordinary objects
    \item they can in particular be inherited from!
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[14]{Generic lambdas}
  \begin{block}{Generic lambdas (aka.\ polymorphic lambdas)}
    \begin{itemize}
      \item The type of lambda parameters may be \cppinline{auto}.
      \begin{cppcode*}{linenos=false,gobble=4}
        auto add = [](auto a, auto b) { return a + b; };
      \end{cppcode*}
      \item The generated \cppinline{operator()} becomes a template function:
      \begin{cppcode*}{linenos=false,gobble=4}
        template <typename T, typename U>
        auto operator()(T a, U b) const { return a + b; }
      \end{cppcode*}
      \item The types of \cppinline{a} and \cppinline{b} may be different.
    \end{itemize}
  \end{block}
  \begin{block}{Explicit template parameters (\cpp20)}
    \begin{itemize}
      \begin{cppcode*}{linenos=false,gobble=4}
        auto add = []<typename T>(T a, T b)
          { return a + b; };
      \end{cppcode*}
      \item The types of \cppinline{a} and \cppinline{b} must be the same.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Higher-order lambdas}
  \begin{exampleblockGB}{Example}{https://godbolt.org/z/GMj76Wer7}{\texttt{lambda}}
    \begin{cppcode*}{}
      auto build_incrementer = [](int inc) {
        return [inc](int value) { return value + inc; };
      };
      auto inc1 = build_incrementer(1);
      auto inc10 = build_incrementer(10);
      int i = 0;
      i = inc1(i);   // i = 1
      i = inc10(i);  // i = 11
    \end{cppcode*}
  \end{exampleblockGB}
  \begin{block}{How it works}
    \begin{itemize}
      \item \cppinline{build_incrementer} returns a function object
      \item this function's behavior depends on a parameter
      \item note how \cppinline{auto} is useful here!
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[20]{Lambda improvements}
  \begin{block}{Lambda improvements in \cpp20}
    \begin{itemize}
      \item Allowed in unevaluated contexts,\\
            e.g.\ within \cppinline{decltype}, \cppinline{sizeof}, \cppinline{typeid}, etc.
      \item Without captures, are default-constructible and assignable
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Examples}
    \small
    \begin{cppcode*}{gobble=2}
      struct S {
        decltype([](int i) { std::cout << i; }) f;
      } s;
      s.f(42); // prints "42"

      template <typename T>
      using CudaPtr = std::unique_ptr<T,
                        decltype([](T* p){ cudaFree(p); })>;

      std::set<T, decltype([](T a, T b) { ... })> s2;
    \end{cppcode*}
  \end{exampleblock}

\end{frame}

\end{advanced}
