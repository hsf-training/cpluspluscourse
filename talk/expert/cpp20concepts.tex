\subsection[tmpl]{Requirements and concepts}

\begin{frame}[fragile]
  \frametitlecpp[20]{Requirements and concepts}
  \begin{block}{Motivation}
    \begin{itemize}
    \item Generic programming is made of variable, function and class templates which can be instantiated with different types.
    \item It is frequent to instantiate them with \textbf{unsuited types}, and the resulting compilation errors are generally very long and hardly understandable.
    \item As a last resort, the template authors are providing \textbf{documentation} about the required parameters, and practice some tricky \textbf{template meta-programmation}.
    \item C++20 brings \textbf{simpler ways to define constraints} on template parameters.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[20]{Requirements and concepts}
  \begin{block}{Old-style SFINAE example}
    \begin{itemize}
    \item The old way to forbid some type arguments is the definition of
    fake template arguments, which lead to a substitution failure when
    the type does not fulfill the condition.
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Original C++17 code}
    \scriptsize
    \begin{cppcode*}{}
    template
    < typename T, std::enable_if_t<!std::is_floating_point_v<T>> * = nullptr>
    bool equal( T e1, T e2 )
    { return (e1==e2) ; }

    template
    < typename T, std::enable_if_t<std::is_floating_point_v<T>> * = nullptr>
    bool equal( T e1, T e2 )
    { return abs(e1-e2)<std::numeric_limits<T>::epsilon() ; }
    \end{cppcode*}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
    \frametitlecpp[20]{Requirements and concepts}
    \begin{block}{Basic requirements}
      \begin{itemize}
        \item The new keyword {\it requires} let us define many kind of requirements
      on the template parameters, with a more readable syntax.
      \end{itemize}
    \end{block}
    \begin{exampleblock}{With {\it requires}}
      \scriptsize
      \begin{cppcode*}{}
      template< typename T>
      bool equal( T e1, T e2 )
      { return (e1==e2) ; }

      template< typename T>
      requires
        (std::is_floating_point_v<T>) &&
        (std::numeric_limits<T>::epsilon()>0)
      bool equal( T e1, T e2 )
      { return abs(e1-e2)<std::numeric_limits<T>::epsilon() ; }
      \end{cppcode*}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
    \frametitlecpp[20]{Requirements and concepts}
    \begin{block}{Concepts}
      \begin{itemize}
        \item When a given set of requirements may be reused often, one should gather them in a concept.
      \end{itemize}
    \end{block}
    \begin{exampleblock}{With {\it concept}}
      \scriptsize
      \begin{cppcode*}{}
      template< typename T>
      concept MyFloatingPoint =
        (std::is_floating_point_v<T>) &&
        (std::numeric_limits<T>::epsilon()>0) ;

      template<typename T>
      requires MyFloatingPoint<T>
      bool equal( T e1, T e2 )
      { return abs(e1-e2)<std::numeric_limits<T>::epsilon() ; }
      \end{cppcode*}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
    \frametitlecpp[20]{Requirements and concepts}
    \begin{block}{Within the template head}
      \begin{itemize}
        \item The concept can also be directly used instead of {it typename} within the template parameter list.
      \end{itemize}
    \end{block}
    \begin{exampleblock}{Instead of {\it typename}}
      \scriptsize
      \begin{cppcode*}{}
      template<MyFloatingPoint T>
      bool equal( T e1, T e2 )
      { return abs(e1-e2)<std::numeric_limits<T>::epsilon() ; }
      \end{cppcode*}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
    \frametitlecpp[20]{Requirements and concepts}
    \begin{block}{With abbreviated function templates}
      \begin{itemize}
        \item The concepts can be used together with {\it auto} in the abbreviated function templates.
      \end{itemize}
    \end{block}
    \begin{exampleblock}{With {\it auto}}
      \scriptsize
      \begin{cppcode*}{}
      bool equal( MyFloatingPoint auto e1, MyFloatingPoint auto e2 )
      { return abs(e1-e2)<std::numeric_limits<T>::epsilon() ; }
      \end{cppcode*}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
    \frametitlecpp[20]{Requirements and concepts}
    \begin{block}{Standard concepts}
      \begin{itemize}
        \item Writing a bug-proof concept is an expert task.
        \item Whenever you can, use the ones provided by the standard library.
        \item Not surprisingly, there is one for floating point numbers.
      \end{itemize}
    \end{block}
    \begin{exampleblock}{With {\it std::}}
      \scriptsize
      \begin{cppcode*}{}
      #include <concepts>

      bool equal( std::floating_point auto e1, std::floating_point auto e2 )
      { return abs(e1-e2)<std::numeric_limits<T>::epsilon() ; }
      \end{cppcode*}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
    \frametitlecpp[20]{Requirements and concepts}
    \begin{block}{Within a function body}
      \begin{itemize}
        \item Concepts are also usable wherever a boolean is expected, including {\it if constexpr}, because they are evaluated at compile-time.
      \end{itemize}
    \end{block}
    \begin{exampleblock}{With {\it if constexpr}}
      \scriptsize
      \begin{cppcode*}{}
      template< typename T>
      bool equal( T e1, T e2 )
      {
        if constexpr (std::floating_point<T>)
        { return abs(e1-e2)<std::numeric_limits<T>::epsilon() ; }
        else
        { return (e1==e2) ; }
      }
      \end{cppcode*}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
    \frametitlecpp[20]{Requirements and concepts}
    \begin{block}{Advanced requirements}
        More than the basic requirements seen before, one may use a \textbf{requires-expression}, able to:
        \begin{itemize}
            \item include basic requirements as before,
            \item list some expressions that must be valid,
            \item check the return type of some expressions.
        \end{itemize}
    \end{block}
    \begin{exampleblock}{Requires-expression}
      \scriptsize
      \begin{cppcode*}{}
      template< typename T>
      concept StreamableAndComparableNumber = requires( T v1, T v2 )
       {
        requires std::integral<T> || std::floating_point<T> ;
        std::cout<<v1<<v2 ;
        { equal(v1,v2) } -> std::convertible_to<bool> ;
       } ;
      \end{cppcode*}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
    \frametitlecpp[20]{Requirements and concepts}
    \begin{block}{To be remembered}
      \begin{itemize}
      \item A template can now {\it requires} properties of its parameters.
      \item Compiler error messages clearly state which argument does not fulfill which requirement.
      \item A typical set of requirements can be gathered in a reusable {\it concept}.
      \item Overload resolution takes those requirements and concepts into account.
      \item The standard library now provides many concepts, easy to use.
      \item Writing from scratch a new bug-proof concept stays an expert topic.
      \end{itemize}
    \end{block}
\end{frame}
