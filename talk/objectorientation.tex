\section[OO]{Object orientation (OO)}

\subsection[OO]{Objects and Classes}

\begin{frame}[fragile]
  \frametitlecpp[98]{What are classes and objects}
  \begin{block}{Classes (or ``user-defined types'')}
    C structs on steroids
    \begin{itemize}
    \item with inheritance
    \item with access control
    \item including methods
    \end{itemize}
  \end{block}
  \begin{block}{Objects}
    instances of classes
  \end{block}
  \begin{block}{A class encapsulates a concept}
    \begin{itemize}
    \item shows an interface
    \item provides its implementation
      \begin{itemize}
      \item status, properties
      \item possible interactions
      \item construction and destruction
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}


\begin{frame}[fragile]
  \frametitlecpp[98]{My First Class}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      struct MyFirstClass {
        int a;
        void squareA() {
          a *= a;
        }
        int sum(int b) {
          return a + b;
        }
      };

      MyFirstClass myObj;
      myObj.a = 2;

      // let's square a
      myObj.squareA();
    \end{cppcode*}
    \columnbreak
    \center
    \null \vfill
    \begin{tikzpicture}
      \classbox{MyFirstClass}{
        int a; \\
        void squareA(); \\
        int sum(int b);
      }
    \end{tikzpicture}
    \vfill \null
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Separating the interface}
  \begin{block}{Header : MyFirstClass.hpp}
    \begin{cppcode*}{}
      #pragma once
      struct MyFirstClass {
        int a;
        void squareA();
        int sum(int b);
      };
    \end{cppcode*}
  \end{block}
  \begin{block}{Implementation : MyFirstClass.cpp}
    \begin{cppcode*}{}
      #include "MyFirstClass.hpp"
      void MyFirstClass::squareA() {
        a *= a;
      }
      void MyFirstClass::sum(int b) {
        return a + b;
      }
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Implementing methods}
  \begin{block}{Standard practice}
    \begin{itemize}
    \item usually in .cpp, outside of class declaration
    \item using the class name as namespace
    \item when reference to the object is needed, use {\it this} keyword
    \end{itemize}
  \end{block}
  \begin{cppcode}
    void MyFirstClass::squareA() {
      a *= a;
    }

    int MyFirstClass::sum(int b) {
      return a + b;
    }
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{{\ttfamily this} keyword}
  \begin{block}{}
    \begin{itemize}
    \item {\ttfamily this} is a hidden parameter to all class methods
    \item it points to the current object
    \item so it is of type {\ttfamily T*} in the methods of class {\ttfamily T}
    \end{itemize}
  \end{block}
  \begin{cppcode}
    void ext_func(MyFirstClass& c) {
      ... do something with c ...
    }

    int MyFirstClass::some_method(...) {
      ext_func(*this);
    }
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Method overloading}
  \begin{block}{The rules in \cpp}
    \begin{itemize}
    \item overloading is authorized and welcome
    \item signature is part of the method identity
    \item but not the return type
    \end{itemize}
  \end{block}
  \begin{cppcode}
    struct MyFirstClass {
      int a;
      int sum(int b);
      int sum(int b, int c);
    }

    int MyFirstClass::sum(int b) { return a + b; }

    int MyFirstClass::sum(int b, int c) {
      return a + b + c;
    }
  \end{cppcode}
\end{frame}

\subsection[inherit]{Inheritance}

\begin{frame}[fragile]
  \frametitlecpp[98]{First inheritance}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      struct MyFirstClass {
        int a;
        void squareA() { a *= a; }
      };
      struct MySecondClass :
        MyFirstClass {
        int b;
        int sum() { return a + b; }
      };

      MySecondClass myObj2;
      myObj2.a = 2;
      myObj2.b = 5;
      myObj2.squareA();
      int i = myObj2.sum(); // i = 9
    \end{cppcode*}
    \columnbreak
    \center
    \null \vfill
    \begin{tikzpicture}[node distance=2.5cm]
      \classbox{MyFirstClass}{
        int a; \\
        void squareA();
      }
      \classbox[below of=MyFirstClass]{MySecondClass}{
        int b; \\
        int sum();
      }
      \draw[very thick,->] (MySecondClass)--(MyFirstClass);
    \end{tikzpicture}
    \vfill \null
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Managing access to class members}
  \begin{block}{{\it public} \color{white} / {\it private} keywords}
    \begin{description}
      \item[private] allows access only within the class
      \item[public] allows access from anywhere
    \end{description}
    \begin{itemize}
       \item The default for \texttt{class} is {\it private}
       \item A \texttt{struct} is just a \texttt{class} that defaults to {\it public} access
    \end{itemize}
  \end{block}
  \pause
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      class MyFirstClass {
      public:
        void setA(int x);
        int getA();
        void squareA();
      private:
        int a;
      };
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{gobble=2,firstnumber=9}
      MyFirstClass obj;
      obj.a = 5;   // error !
      obj.setA(5); // ok
      obj.squareA();
      int b = obj.getA();
    \end{cppcode*}
    \pause
    \begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,colback=red!5!white,colframe=red!75!black]
      This breaks MySecondClass !
    \end{tcolorbox}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Managing access to class members(2)}
  \begin{block}{Solution is {\it protected} keyword}
    Gives access to classes inheriting from base class
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      class MyFirstClass {
      public:
        void setA(int a);
        int getA();
        void squareA();
      protected:
        int a;
      };
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{gobble=2,firstnumber=13}
      class MySecondClass :
        public MyFirstClass {
      public:
        int sum() {
          return a + b;
        }
      private:
        int b;
      };
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Managing inheritance privacy}
  \begin{block}{Inheritance can be public, protected or private}
    It influences the privacy of inherited members for external code.\\
    The code of the class itself is not affected
    \begin{description}
    \item[public] privacy of inherited members remains unchanged
    \item[protected] inherited public members are seen as protected
    \item[private] all inherited members are seen as private \\
      this is the default for \texttt{class} if nothing is specified
    \end{description}
  \end{block}
  \pause
  \begin{block}{Net result for external code}
    \begin{itemize}
    \item only public members of public inheritance are accessible
    \end{itemize}
  \end{block}
  \begin{block}{Net result for grand child code}
    \begin{itemize}
    \item only public and protected members of public and protected parents are accessible
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Managing inheritance privacy - public}
  \begin{multicols}{2}
    \begin{tikzpicture}[node distance=3cm]
      \classbox{MyFirstClass}{
      private: \\
        \hspace{0.4cm}int priv; \\
      protected: \\
        \hspace{0.4cm}int prot; \\
      public: \\
        \hspace{0.4cm}int pub;
      }
      \classbox[below of=MyFirstClass]{MySecondClass}{
        void funcSecond();
      }
      \classbox[below of=MySecondClass,node distance=1.75cm]{MyThirdClass}{
        void funcThird();
      }
      \draw[very thick,->] (MySecondClass)--(MyFirstClass) node[midway,right] {public};
      \draw[very thick,->] (MyThirdClass)--(MySecondClass) node[midway,right] {public};
    \end{tikzpicture}
    \columnbreak
    \begin{cppcode*}{gobble=2}
      void funcSecond() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void funcThird() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void extFunc(MyThirdClass t) {
        int a = t.priv; // Error
        int b = t.prot; // Error
        int c = t.pub;  // OK
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Managing inheritance privacy - protected}
  \begin{multicols}{2}
    \begin{tikzpicture}[node distance=3cm]
      \classbox{MyFirstClass}{
      private: \\
        \hspace{0.4cm}int priv; \\
      protected: \\
        \hspace{0.4cm}int prot; \\
      public: \\
        \hspace{0.4cm}int pub;
      }
      \classbox[below of=MyFirstClass]{MySecondClass}{
        void funcSecond();
      }
      \classbox[below of=MySecondClass,node distance=1.75cm]{MyThirdClass}{
        void funcThird();
      }
      \draw[very thick,->] (MySecondClass)--(MyFirstClass) node[midway,right] {protected};
      \draw[very thick,->] (MyThirdClass)--(MySecondClass) node[midway,right] {public};
    \end{tikzpicture}
    \columnbreak
    \begin{cppcode*}{gobble=2}
      void funcSecond() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void funcThird() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void extFunc(MyThirdClass t) {
        int a = t.priv; // Error
        int b = t.prot; // Error
        int c = t.pub;  // Error
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Managing inheritance privacy - private}
  \begin{multicols}{2}
    \begin{tikzpicture}[node distance=3cm]
      \classbox{MyFirstClass}{
      private: \\
        \hspace{0.4cm}int priv; \\
      protected: \\
        \hspace{0.4cm}int prot; \\
      public: \\
        \hspace{0.4cm}int pub;
      }
      \classbox[below of=MyFirstClass]{MySecondClass}{
        void funcSecond();
      }
      \classbox[below of=MySecondClass,node distance=1.75cm]{MyThirdClass}{
        void funcThird();
      }
      \draw[very thick,->] (MySecondClass)--(MyFirstClass) node[midway,right] {private};
      \draw[very thick,->] (MyThirdClass)--(MySecondClass) node[midway,right] {public};
    \end{tikzpicture}
    \columnbreak
    \begin{cppcode*}{gobble=2}
      void funcSecond() {
        int a = priv;   // Error
        int b = prot;   // OK
        int c = pub;    // OK
      }
      void funcThird() {
        int a = priv;   // Error
        int b = prot;   // Error
        int c = pub;    // Error
      }
      void extFunc(MyThirdClass t) {
        int a = t.priv; // Error
        int b = t.prot; // Error
        int c = t.pub;  // Error
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Final class}
  \begin{block}{Idea}
    \begin{itemize}
    \item make sure you cannot inherit from a given class
    \item by declaring it final
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      struct Base final {
        ...
      };
      struct Derived : Base { // compiler error
        ...
      };
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\subsection[construct]{Constructors/destructors}

\begin{frame}[fragile]
  \frametitlecpp[98]{Class Constructors and Destructors}
  \begin{block}{Concept}
    \begin{itemize}
    \item special functions building/destroying an object
    \item a class can have several constructors
    \item the constructors have the same name as the class
    \item same for the destructor with a leading $\sim$
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      class MyFirstClass {
      public:
        MyFirstClass();
        MyFirstClass(int a);
        ~MyFirstClass();
        ...
      protected:
        int a;
      };
    \end{cppcode*}
    \columnbreak
    \begin{cppcode*}{gobble=2,firstnumber=10}
      // note special notation for
      // initialization of members
      MyFirstClass() : a(0) {}

      MyFirstClass(int a_):a(a_) {}

      ~MyFirstClass() {}
    \end{cppcode*}
  \end{multicols}
\end{frame}


\begin{frame}[fragile]
  \frametitlecpp[98]{Class Constructors and Destructors}
  \begin{cppcode}
    class Vector {
    public:
      Vector(int n);
      ~Vector();
      void setN(int n, int value);
      int getN(int n);
    private:
      int len;
      int* data;
    };
    Vector::Vector(int n) : len(n) {
      data = new int[n];
    }
    Vector::~Vector() {
      delete[] data;
    }
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Constructor and inheritance}
  \begin{cppcode}
    struct MyFirstClass {
      int a;
      MyFirstClass();
      MyFirstClass(int a);
    };
    struct MySecondClass : MyFirstClass {
      int b;
      MySecondClass();
      MySecondClass(int b);
      MySecondClass(int a, int b);
    };
    MySecondClass() : MyFirstClass(), b(0) {}
    MySecondClass(int b_) : MyFirstClass(), b(b_) {}
    MySecondClass(int a_,
                  int b_) : MyFirstClass(a_), b(b_) {}
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Copy constructor}
  \begin{block}{Concept}
    \begin{itemize}
    \item special constructor called for replicating an object
    \item takes a single parameter of type const ref to class
    \item will be implemented by the compiler if not provided
    \item in order to forbid copy, use {\texttt delete} (coming in 2 slides)
      \begin{itemize}
      \item or private copy constructor with no implementation in \cpp98
      \end{itemize}
    \end{itemize}
  \end{block}
  \pause
  \begin{cppcode}
    struct MySecondClass : MyFirstClass {
      MySecondClass();
      MySecondClass(const MySecondClass &other);
    };
  \end{cppcode}
  \pause
  \begin{exampleblock}{The rule of 3/5 (\cpp98/\cpp11 and newer)}
    \begin{itemize}
    \item if a class has a destructor, a copy/move constructor or a (move) assignment operator, it should have all three/five
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Class Constructors and Destructors}
  \begin{cppcode}
    class Vector {
    public:
      Vector(int n);
      Vector(const Vector &other);
      ~Vector();
      ...
    };
    Vector::Vector(int n) : len(n) {
      data = new int[n];
    }
    Vector::Vector(const Vector &other) : len(other.len) {
      data = new int[len];
      memcpy(data, other.data, len);
    }
    Vector::~Vector() { delete[] data; }
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Default Constructor}
  \begin{block}{Idea}
    \begin{itemize}
    \item avoid writing explicitly default constructors
    \item by declaring them as default
    \end{itemize}
  \end{block}
  \begin{block}{Details}
    \begin{itemize}
    \item when no user defined constructor, a default is provided
    \item any user defined constructor disables default ones
    \item but they can be enforced
    \item rule can be more subtle depending on members
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      ClassName() = default;  // provide/force default
      ClassName() = delete;   // do not provide default
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Constructor delegation}
  \begin{block}{Idea}
    \begin{itemize}
    \item avoid replication of code in several constructors
    \item by delegating to another constructor, in the initializer list
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      struct Delegate {
        int m_i;
        Delegate() { ... complex initialization ...}
        Delegate(int i) : Delegate(), m_i(i) {}
      };
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Constructor inheritance}
  \begin{block}{Idea}
    \begin{itemize}
    \item avoid having to re-declare parent's constructors
    \item by stating that we inherit all parent constructors
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      struct BaseClass {
        BaseClass(int value);
      };
      struct DerivedClass : BaseClass {
        using BaseClass::BaseClass;
      };
      DerivedClass a{5};
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Member initialization}
  \begin{block}{Idea}
    \begin{itemize}
    \item avoid redefining same default value for members n times
    \item by defining it once at member declaration time
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      struct BaseClass {
        int a{5};
        BaseClass() = default;
        BaseClass(int _a) : a(_a) {}
      };
      struct DerivedClass : BaseClass {
        int b{6};
        using BaseClass::BaseClass;
      };
      DerivedClass d{7}; // a = 7, b = 6
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Calling constructors}
  \begin{block}{After object declaration, arguments within \{\}}
    \begin{multicols}{2}
      \begin{cppcode*}{gobble=4}
        struct A {
          int a;
          float b;
          A();
          A(int);
          A(int, int);
        };
      \end{cppcode*}
      \columnbreak
      \begin{cppcode*}{gobble=4,firstnumber=8}
        struct B {
          int a;
          float b;
        };
      \end{cppcode*}
    \end{multicols}
    \begin{cppcode*}{gobble=2, firstnumber=12}
      A a{1,2};       // A::A(int, int)
      A a{1};         // A::A(int)
      A a{};          // A::A()
      A a;            // A::A()
      A a = {1,2};    // A::A(int, int)
      B b = {1, 2.3}; // list initialization
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Calling constructors the old way}
  \begin{block}{Arguments are given within (), aka \cpp98 nightmare}
    \begin{multicols}{2}
      \begin{cppcode*}{gobble=4}
        struct A {
          int a;
          float b;
          A();
          A(int);
          A(int, int);
        };
      \end{cppcode*}
      \columnbreak
      \begin{cppcode*}{gobble=4,firstnumber=8}
        struct B {
          int a;
          float b;
        };
      \end{cppcode*}
    \end{multicols}
    \begin{cppcode*}{gobble=2, firstnumber=12}
      A a(1,2);       // A::A(int, int)
      A a(1);         // A::A(int)
      A a();          // declaration of a function !
      A a;            // A::A()
      A a = {1,2};    // not allowed
      B b = {1, 2.3}; // OK
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Calling constructors for arrays and vectors}
  \begin{exampleblock}{list of items given within \{\}}
    \begin{cppcode*}{firstnumber=10}
     int ip[3]{1,2,3};
     int* ip = new int[3]{1,2,3};
     std::vector<int> v{1,2,3};
    \end{cppcode*}
  \end{exampleblock}
  \pause
  \begin{block}{\cpp98 nightmare}
    \begin{cppcode*}{firstnumber=10}
     int ip[3]{1,2,3};            // OK
     int* ip = new int[3]{1,2,3}; // not allowed
     std::vector<int> v{1,2,3};   // not allowed
    \end{cppcode*}
  \end{block}
\end{frame}

\subsection[static]{Static members}

\begin{frame}[fragile]
  \frametitlecpp[98]{Static members}
  \begin{block}{Concept}
    \begin{itemize}
    \item members attached to a class rather than to an object
    \item usable with or without an instance of the class
    \item identified by the {\it static} keyword
    \end{itemize}
  \end{block}
  \begin{cppcode}
    class Text {
    public:
      static std::string upper(std::string) {...}
    private:
      static int s_nbCallsToUpper;
    };
    int Text::s_nbCallsToUpper = 0;
    std::string uppers = Text::upper("my text");
    // now Text::s_nbCallsToUpper is 1
  \end{cppcode}
\end{frame}

\subsection[new]{Allocating objects}

\begin{frame}[fragile]
  \frametitlecpp[98]{Process memory organization}
  \begin{block}{4 main areas}
    \begin{description}
    \item[the code segment] for the code of the executable
    \item[the data segment] for global variables
    \item[the heap] for dynamically allocated variables
    \item[the stack] for parameters of functions and local variables
    \end{description}
  \end{block}
  \hspace{2.5cm}
  \begin{tikzpicture}
    \memorystack[size x=5cm,word size=1,nb blocks=6,addresses=0]
    \memorypush{code segment}
    \memorypush{data segment}
    \memorypush{stack}
    \memorypush{...}
    \memorypush{...}
    \memorypush{heap}
    \draw[->] (stack3-1.north) ++(-1cm,0) -- +(0,.3cm);
    \draw[->] (stack3-1.north) ++(1cm,0) -- +(0,.3cm);
    \draw[->] (stack6-1.south) ++(-1cm,0) -- +(0,-.3cm);
    \draw[->] (stack6-1.south) ++(1cm,0) -- +(0,-.3cm);
  \end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{The Stack}
  \begin{block}{Main characteristics}
    \begin{itemize}
    \item allocation on the stack stays valid for the duration of the current scope.
    It is destroyed when it is popped off the stack.
    \item memory allocated on the stack is known at compile time and can thus be accessed through a variable.
    \item the stack is relatively small, it is not a good idea to allocate large arrays, structures or classes
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Object allocation on the stack}
  \begin{block}{On the stack}
    \begin{itemize}
    \item objects are created when declared (constructor called)
    \item objects are destructed when out of scope (destructor is called)
    \end{itemize}
  \end{block}
  \begin{cppcode}
    int f() {
      MyFirstClass a{3}; // constructor called
      ...
    } // destructor called

    {
      MyFirstClass a; // default constructor called
      ...
    }  // destructor called
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{The Heap}
  \begin{block}{Main characteristics}
    \begin{itemize}
    \item Allocated memory stays allocated until it is specifically deallocated
      \begin{itemize}
      \item beware memory leaks
      \end{itemize}
    \item Dynamically allocated memory must be accessed through pointers
    \item large arrays, structures, or classes should be allocated here
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Object allocation on the heap}
  \begin{block}{On the heap}
    \begin{itemize}
    \item object are created by calling {\it new} (constructor is called)
    \item object are destructed by calling {\it delete} (destructor is called)
    \end{itemize}
  \end{block}
  \begin{cppcode}
    {
      // default constructor called
      MyFirstClass *a = new MyFirstClass;
      ...
      delete a; // destructor is called
    }

    int f() {
      // constructor called
      MyFirstClass *a = new MyFirstClass(3);
      ...
    } // memory leak !!!
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Array allocation on the heap}
  \begin{block}{Arrays on the heap}
    \begin{itemize}
    \item arrays of objects are created by calling {\it new[]} \\
      default constructor is called for each object of the array
    \item arrays of object are destructed by calling {\it delete[]} \\
      destructor is called for each object of the array
    \end{itemize}
  \end{block}
  \begin{cppcode}
    {
      // default constructor called 10 times
      MyFirstClass *a = new MyFirstClass[10];
      ...
      delete[] a; // destructor called 10 times
    }
  \end{cppcode}
\end{frame}

\subsection[advOO]{Advanced OO}

\begin{frame}[fragile]
  \frametitlecpp[98]{Polymorphism}
  \begin{block}{the concept}
    \begin{itemize}
    \item objects actually have multiple types simultaneously
    \item and can be used as any of them
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      Polygon p;

      int f(Drawable & d) {...}
      f(p);  //ok

      try {
        throw p;
      } catch (Shape & e) {
        // will be caught
      }
    \end{cppcode*}
    \columnbreak
    \center
    \begin{tikzpicture}[node distance=1.5cm]
      \classbox{Drawable}{}
      \classbox[below of=Drawable]{Shape}{}
      \classbox[below of=Shape]{Polygon}{}
      \draw[very thick,->] (Polygon) -- (Shape);
      \draw[very thick,->] (Shape) -- (Drawable);
    \end{tikzpicture}
  \end{multicols}
\end{frame}


\begin{frame}[fragile]
  \frametitlecpp[98]{Inheritance privacy and polymorphism}
  \begin{block}{Only public inheritance is visible to code outside the class}
    \begin{itemize}
    \item private and protected are not
    \item this may restrict usage of polymorphism
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      Polygon p;

      int f(Drawable & d) {...}
      f(p);  // Not ok anymore

      try {
        throw p;
      } catch (Shape & e) {
        // ok, will be caught
      }
    \end{cppcode*}
    \columnbreak
    \center
    \begin{tikzpicture}[node distance=1.5cm]
      \classbox{Drawable}{}
      \classbox[below of=Drawable]{Shape}{}
      \classbox[below of=Shape]{Polygon}{}
      \draw[very thick,->] (Polygon) -- (Shape) node[midway,right] {public};
      \draw[very thick,->] (Shape) -- (Drawable) node[midway,right] {private};
    \end{tikzpicture}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Method overriding}
  \begin{block}{the problem}
    \begin{itemize}
    \item a given method of the parent can be overridden in a child
    \item but which one is called ?
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      Polygon p;
      p.draw(); // ?

      Shape & s = p;
      s.draw(); // ?
    \end{cppcode*}
    \columnbreak
    \center
    \begin{tikzpicture}[node distance=1.5cm]
      \classbox{Drawable}{
        void draw();
      }
      \classbox[below of=Drawable]{Shape}{}
      \classbox[below of=Shape]{Polygon}{
        void draw();
      }
      \draw[very thick,->] (Polygon) -- (Shape);
      \draw[very thick,->] (Shape) -- (Drawable);
    \end{tikzpicture}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Virtual methods}
  \begin{block}{the concept}
    \begin{itemize}
    \item methods can be declared \mintinline{cpp}{virtual}
    \item for these, the most derived object is always considered
    \item for others, the type of the variable decides
    \end{itemize}
  \end{block}
  \begin{overprint}
  \onslide<2>
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      Polygon p;
      p.draw(); // Polygon.draw

      Shape & s = p;
      s.draw(); // Drawable.draw
    \end{cppcode*}
    \columnbreak
    \center
    \begin{tikzpicture}[node distance=1.5cm]
      \classbox{Drawable}{
        \mintinline{cpp}{void draw();}
      }
      \classbox[below of=Drawable]{Shape}{}
      \classbox[below of=Shape]{Polygon}{
        \mintinline{cpp}{void draw();}
      }
      \draw[very thick,->] (Polygon) -- (Shape);
      \draw[very thick,->] (Shape) -- (Drawable);
    \end{tikzpicture}
  \end{multicols}

  \onslide<3>
    \begin{multicols}{2}
    \begin{cppcode*}{gobble=2,highlightlines=5}
      Polygon p;
      p.draw(); // Polygon.draw

      Shape & s = p;
      s.draw(); // Polygon.draw
    \end{cppcode*}
    \columnbreak
    \center
    \begin{tikzpicture}[node distance=1.5cm]
      \classbox{Drawable}{
        \mintinline{cpp}{virtual void draw();}
      }
      \classbox[below of=Drawable]{Shape}{}
      \classbox[below of=Shape]{Polygon}{
        \mintinline{cpp}{void draw();}
      }
      \draw[very thick,->] (Polygon) -- (Shape);
      \draw[very thick,->] (Shape) -- (Drawable);
    \end{tikzpicture}
  \end{multicols}
  \end{overprint}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Virtual methods - implications}
  \begin{block}{Mechanics}
    \begin{itemize}
    \item virtual methods are deduced at run time
      \begin{itemize}
      \item while non-virtual methods are deduced at compile time
      \end{itemize}
    \item they also imply extra storage and an extra indirection
      \begin{itemize}
      \item practically the object stores a pointer to the correct method
      \item in a so-called ``virtual table'' (``vtable'')
      \end{itemize}
    \end{itemize}
  \end{block}
  \begin{alertblock}{Consequences}
    \begin{itemize}
    \item virtual methods are ``slower'' than standard ones
    \item and they cannot be inlined
    \item templates are an alternative for performance-critical cases
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{{\texttt override} keyword}
  \begin{block}{Principle}
    \begin{itemize}
    \item when overriding a virtual method
    \item the \mintinline{cpp}|override| keyword needs to be used
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      struct Base {
        virtual void some_func(float);
      };
      struct Derived : Base {
        void some_func(float) override;
      };
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{Why was {\texttt override} keyword introduced ?}
  To detect the mistake in the following code :
  \begin{block}{Without {\texttt override} (\cpp98)}
    \begin{cppcode}
      struct Base {
        virtual void some_func(float);
      };
      struct Derived : Base {
        void some_func(double); // oops !
      };
    \end{cppcode}
  \end{block}
  \begin{itemize}
  \item with \mintinline{cpp}|override|, you would get a compiler error
  \item if you forget \mintinline{cpp}|override| when you should have it, you get a compiler warning
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[11]{{\texttt final} keyword}
  \begin{block}{Idea}
    \begin{itemize}
    \item make sure you cannot override further a given virtual method
    \item by declaring it final
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Practically}
    \begin{cppcode}
      struct Base {
        virtual void some_func(float);
      };
      struct Intermediate : Base {
        void some_func(float) final;
      };
      struct Derived : Intermediate {
        void some_func(float) override; // error
      };
    \end{cppcode}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Pure Virtual methods}
  \begin{block}{Concept}
    \begin{itemize}
    \item methods that exist but are not implemented
      \item marked by ``{\tt = 0} '' in the declaration
    \item makes their class abstract
    \item an object can only be instantiated for a non-abstract class
    \end{itemize}
  \end{block}
  \pause
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      // Error : abstract class
      Shape s;

      // ok, draw has been implemented
      Polygon p;

      // Shape type still usable
      Shape & s = p;
      s.draw();
    \end{cppcode*}
    \columnbreak
    \begin{tikzpicture}[node distance=1.5cm]
      \classbox{Drawable}{
        \mintinline{cpp}{virtual void draw() = 0;}
      }
      \classbox[below of=Drawable]{Shape}{}
      \classbox[below of=Shape]{Polygon}{
        \mintinline{cpp}{void draw() override;}
      }
      \draw[very thick,->] (Polygon) -- (Shape);
      \draw[very thick,->] (Shape) -- (Drawable);
    \end{tikzpicture}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Pure Abstract Class aka Interface}
  \begin{block}{Definition of pure abstract class}
    \begin{itemize}
    \item a class that has
      \begin{itemize}
        \item no data member
        \item all its methods pure virtual
      \end{itemize}
    \item the equivalent of an Interface in Java
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{cppcode*}{gobble=2}
      struct Drawable {
        virtual void draw() = 0;
      }
    \end{cppcode*}
    \columnbreak
    \center
    \begin{tikzpicture}[node distance=1.5cm]
      \classbox{Drawable}{
        virtual void draw() = 0;
      }
    \end{tikzpicture}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Overriding overloaded methods}
  \begin{block}{Concept}
    \begin{itemize}
    \item overriding an overloaded method will hide the others
    \item unless you inherit them using \mintinline{cpp}{using}
    \end{itemize}
  \end{block}
  \begin{cppcode*}{gobble=0}
    struct BaseClass {
      int foo(std::string);
      int foo(int);
    };
    struct DerivedClass : BaseClass {
      using BaseClass::foo;
      int foo(std::string);
    };
    DerivedClass dc;
    dc.foo(4);      // error if no using
    \end{cppcode*}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Polymorphism}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go to code/polymorphism
    \item look at the code
    \item open trypoly.cpp
    \item create a Pentagon, call its perimeter method
    \item create a Hexagon, call its perimeter method
    \item create a Hexagon, call its parent's perimeter method
    \item retry with virtual methods
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Multiple Inheritance}
  \begin{block}{Concept}
    \begin{itemize}
    \item one class can inherit from multiple parents
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{tikzpicture}[]
      \classbox[]{Polygon}{}
      \classbox[below of=Polygon,node distance=1.5cm]{Rectangle}{}
      \classbox[right of=Rectangle,node distance=3cm]{Text}{}
      \classbox[below right of=Rectangle,node distance=2cm]{TextBox}{}
      \draw[very thick,->] (Polygon) -- (Rectangle);
      \draw[very thick,->] (Rectangle) -- (TextBox);
      \draw[very thick,->] (Text) -- (TextBox);
    \end{tikzpicture}
    \columnbreak
    \vspace{2cm}
    \begin{cppcode*}{gobble=2}
      class TextBox :
        public Rectangle, Text {
        // inherits from both
        // publicly from Rectangle
        // privately from Text
      }
    \end{cppcode*}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{The diamond shape}
  \begin{block}{Definition}
    \begin{itemize}
    \item situation when one class inherits several times from a given grand parent
    \end{itemize}
  \end{block}
  \begin{alertblock}{Problem}
    \begin{itemize}
    \item are the members of the grand parent replicated ?
    \end{itemize}
  \end{alertblock}
  \vfill
  \hspace{2.5cm}
  \begin{tikzpicture}[]
    \classbox[]{Drawable}{}
    \classbox[below left of=Drawable,node distance=2cm]{Rectangle}{}
    \classbox[right of=Rectangle,node distance=3cm]{Text}{}
    \classbox[below right of=Rectangle,node distance=2cm]{TextBox}{}
    \draw[very thick,->] (Drawable) -- (Rectangle);
    \draw[very thick,->] (Drawable) -- (Text);
    \draw[very thick,->] (Rectangle) -- (TextBox);
    \draw[very thick,->] (Text) -- (TextBox);
  \end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Virtual inheritance}
  \begin{block}{Solution}
    \begin{itemize}
    \item inheritance can be {\it virtual} or not
    \item {\it virtual} inheritance will ``share'' parents
    \item standard inheritance will replicate them
    \end{itemize}
    \begin{cppcode}
      class Text : public virtual Drawable {...};
      class Rectangle : public virtual Drawable {...};
    \end{cppcode}
  \end{block}
  \begin{multicols}{2}
    \begin{tikzpicture}[]
      \classbox[below of=title]{Drawable}{}
      \classbox[below left of=Drawable,node distance=2cm]{Rectangle}{}
      \classbox[right of=Rectangle,node distance=3cm]{Text}{}
      \classbox[below right of=Rectangle,node distance=2cm]{TextBox}{}
      \draw[very thick,->] (Drawable) -- node[below,pos=0.35,sloped] {\scriptsize virtual} (Rectangle);
      \draw[very thick,->] (Drawable) -- node[below,pos=0.45,sloped] {\scriptsize virtual} (Text);
      \draw[very thick,->] (Rectangle) -- (TextBox);
      \draw[very thick,->] (Text) -- (TextBox);
    \end{tikzpicture}
    \columnbreak
    \begin{tikzpicture}[]
      \classbox[]{Drawable1}{}
      \classbox[below of=Drawable1,node distance=1.5cm]{Rectangle}{}
      \draw[very thick,->] (Drawable1) -- (Rectangle);
      \classbox[right of=Drawable1,node distance=3cm]{Drawable2}{}
      \classbox[below of=Drawable2,node distance=1.5cm]{Text}{}
      \draw[very thick,->] (Drawable2) -- (Text);
      \classbox[below right of=Rectangle,node distance=2cm]{TextBox}{}
      \draw[very thick,->] (Rectangle) -- (TextBox);
      \draw[very thick,->] (Text) -- (TextBox);
    \end{tikzpicture}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Multiple inheritance advice}
  \begin{block}{Do not use multiple inheritance}
    \begin{itemize}
    \item Except for inheriting from interfaces
    \item and for rare special cases
    \end{itemize}
  \end{block}
  \pause
  \begin{alertblock}{Do not use diamond shapes}
    \begin{itemize}
    \item This is a sign that your architecture is not correct
    \item In case you are tempted, think twice and change mind
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Virtual inheritance}
  \begin{alertblock}{Exercise Time}
    \begin{itemize}
    \item go to code/virtual\_inheritance
    \item look at the code
    \item open trymultiherit.cpp
    \item create a TextBox and call draw
    \item Fix the code to call both draws by using types
    \item retry with virtual inheritance
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Virtual inheritance}
  \begin{alertblock}{Warning}
    in case of virtual inheritance it is the most derived class that calls the virtual base class's constructor
  \end{alertblock}
\end{frame}


\subsection[Op]{Operators}

\begin{frame}[fragile]
  \frametitlecpp[98]{Operators' example}
  \begin{cppcode}
    struct Complex {
      float m_real, m_imaginary;
      Complex(float real, float imaginary);
      Complex operator+(const Complex& other) {
        return Complex(m_real + other.m_real,
                       m_imaginary + other.m_imaginary);
      }
    };

    Complex c1{2, 3}, c2{4, 5};
    Complex c3 = c1 + c2; // (6, 8)
  \end{cppcode}
\end{frame}

\begin{frame}
  \frametitlecpp[98]{Operators}
  \begin{block}{Definition for operators of a class}
    \begin{itemize}
    \item implemented as a regular method
      \begin{itemize}
      \item either inside the class, as a member function
      \item or outside the class (not all)
      \end{itemize}
    \item with a special name (replace @ by anything)
      \begin{tabular}{llll}
        Expression & As member & As non-member \\
        \hline
        @a & (a).operator@() & operator@(a) \\
        a@b & (a).operator@(b) & operator@(a,b) \\
        a=b & (a).operator=(b) & cannot be non-member \\
        a(b...) & (a).operator()(b...) & cannot be non-member \\
        a[b] & (a).operator[](b) & cannot be non-member \\
        a-\textgreater & (a).operator-\textgreater() & cannot be non-member \\
        a@ & (a).operator@(0) & operator@(a,0) \\
      \end{tabular}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Why to have non-member operators ?}
  \begin{block}{Symmetry}
    \begin{cppcode}
      struct Complex {
        float m_real, m_imaginary;
        Complex operator+(float other) {
          return Complex(m_real + other, m_imaginary);
        }
      };
      Complex c1{2.f, 3.f};
      Complex c2 = c1 + 4.f;  // ok
      Complex c3 = 4.f + c1;  // not ok !!
    \end{cppcode}
    \pause
    \begin{cppcode*}{firstnumber=10}
      Complex operator+(float a, const Complex& obj) {
        return Complex(a + obj.m_real, obj.m_imaginary);
      }
    \end{cppcode*}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Other reason to have non-member operators ?}
  \begin{block}{Extending existing classes}
    \begin{cppcode}
      struct Complex {
        float m_real, m_imaginary;
        Complex(float real, float imaginary);
      };

      std::ostream& operator<<(std::ostream& os,
                               const Complex& obj) {
        os << "(" << obj.m_real << ", "
                  << obj.m_imaginary << ")";
        return os;
      }
      Complex c1{2.f, 3.f};
      std::cout << c1 << std::endl; // Prints '(2, 3)'
    \end{cppcode}
  \end{block}
\end{frame}

\subsection[()]{Functors}

\begin{frame}[fragile]
  \frametitlecpp[98]{Functors}
  \begin{block}{Concept}
    \begin{itemize}
    \item a class that implements the () operator
    \item allows to use objects in place of functions
    \item and as objects have constructors, allow to construct functions
    \end{itemize}
  \end{block}
  \begin{cppcode}
    struct Adder {
      int m_increment;
      Adder(int increment) : m_increment(increment) {}
      int operator()(int a) { return a + m_increment; }
    };

    Adder inc1{1}, inc10{10};
    int i = 3;
    int j = inc1(i);  // 4
    int k = inc10(i); // 13
    int l = Adder{25}(i); // 28
  \end{cppcode}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{Functors}
  \begin{block}{Typical usage}
    \begin{itemize}
    \item pass a function to another one
    \item or to an STL algorithm
    \end{itemize}
  \end{block}
  \begin{cppcode}
    struct BinaryFunction {
      virtual double operator() (double a, double b) = 0;
    };
    struct Add : public BinaryFunction {
      double operator() (double a, double b) override
      { return a+b; }
    };
    double binary_op(double a, double b, BinaryFunction &func) {
      return func(a, b);
    }
    Add addfunc;
    double c = binary_op(a, b, addfunc);
  \end{cppcode}
\end{frame}

\subsection[ADL]{Name Lookups}

\begin{frame}[fragile]
  \frametitlecpp[98]{Basics of name lookup}
  \begin{exampleblock}{Example code}
    \begin{cppcode}
      std::cout << std::endl;
    \end{cppcode}
  \end{exampleblock}
  \begin{block}{How to find the declaration of a name ?}
    Mainly 2 cases :
    \begin{itemize}
    \item qualified lookup, for names preceded by `::'
      \begin{itemize}
      \item here \mintinline{cpp}{cout} and \mintinline{cpp}{endl}
      \item name is only looked for in given class/namespace/enum class
      \end{itemize}
    \item unqualified lookup
      \begin{itemize}
      \item here for \mintinline{cpp}{std}
      \item name is looked for in a sequence of scopes until found
      \item remaining scopes are not examined
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitlecpp[98]{Unqualified name lookup and ADL}
  \begin{block}{Ordered list of scopes (simplified)}
    \begin{itemize}
    \item file (only for global level usage)
    \item current namespace/block, parent namespace/block, etc...
    \item current class if any, base class if any, etc...
    \item for names used to the left of the () operator, Argument Dependent Lookup (ADL)
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Argument Dependent Lookup (simplified)}
    For each argument of a function call, the function name is also searched in:
    \begin{itemize}
    \item the class of the argument's type if any
    \item its direct and indirect base classes if any
    \item the enclosing namespace of all these classes
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{ADL consequences (1)}
  \begin{block}{Use standalone/non-member functions}
    When a method is not accessing the private part of a class, make it a function in the same namespace
    \vspace{-1mm}
    \begin{columns}[T]
      \begin{column}{.35\textwidth}
        Don't write :
        \vspace{-1mm}
        \begin{cppcode*}{gobble=6}
          namespace MyNS {
            struct A {
              T func(...);
            };
          }
        \end{cppcode*}
      \end{column}
      \begin{column}{.35\textwidth}
        Prefer :
        \vspace{-1mm}
        \begin{cppcode*}{gobble=6,firstnumber=6}
          namespace MyNS {
            struct A { ... };
            T func(const A&, ..);
          }
        \end{cppcode*}
      \end{column}
    \end{columns}
    \vspace{.2cm}
    Advantages :
    \begin{itemize}
    \item minimal change in user code, func still feels part of A class
    \item makes sure func does not touch internal state of A
    \end{itemize}
    Notes :
    \begin{itemize}
    \item non-member func has to be in same namespace as A
    \item please avoid global namespace
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[17]{ADL consequences (2)}
  \begin{block}{Prefer nested namespaces to \texttt{using}}
    Don't write :
    \begin{cppcode}
      using namespace MyProject;
      funcFromMyProject(...);
    \end{cppcode}
    Prefer :
    \begin{cppcode*}{firstnumber=3}
      namespace MyProject::MySubpart {
        funcFromMyProject(...);
      }
    \end{cppcode*}
    And let the compiler lookup (more easily) the function name
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitlecpp[98]{ADL consequences (3)}
  \begin{block}{Customization points and \texttt{using}}
    \begin{columns}[t]
      \begin{column}{.35\textwidth}
        Don't write :
        \begin{cppcode*}{gobble=6}
          namespace N {
            A a,b;
            std::swap(a, b);
          }
        \end{cppcode*}
      \end{column}
      \begin{column}{.35\textwidth}
        Prefer :
        \begin{cppcode*}{gobble=6,firstnumber=5}
          namespace N {
            A a,b;
            using std::swap;
            swap(a, b);
          }
        \end{cppcode*}
      \end{column}
    \end{columns}
    \vspace{.2cm}
    Advantages :
    \begin{itemize}
    \item allows to use \mintinline{cpp}{std::swap} by default
    \item but also to benefit from any dedicated specialization
    \end{itemize}
    \begin{columns}
      \begin{column}{.7\textwidth}
        \begin{cppcode*}{gobble = 6,firstnumber=10}
          namespace N {
            // optimized swap for A
            void swap(A&, A&);
          }
        \end{cppcode*}
      \end{column}
    \end{columns}
  \end{block}
\end{frame}
